---
# -- The api versions of the resources created by this chart.
#
# Ref: https://kubernetes.io/docs/reference/using-api/deprecation-guide/
apiVersions:
  deployment: "apps/v1"
  horizontalPodAutoscaler: "autoscaling/v2"
  ingress: "networking.k8s.io/v1"
  persistentVolumeClaim: "v1"
  podDisruptionBudget: "policy/v1"
  service: "v1"
  serviceAccount: "v1"
  serviceMonitor: "monitoring.coreos.com/v1"
  configMap: "v1"
  statefulSet: "apps/v1"

# -- Use this to override the name of the chart.
nameOverride: ""

# -- Use this to override the fullname of the chart.
fullnameOverride: ""

# -- Use this to override the namespace of the chart.
# By default, `.Release.Namespace` is used.
namespaceOverride: ""

# -- The number of replicas of the pod.
# Will not be used if `.Values.autoscaling.enabled` is `true`.
# `romm` makes no statement about multi-instance support, increase this at your own risk.
#
# Ref: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
replicaCount: 1

# -- The image of the container.
#
# Ref: https://kubernetes.io/docs/concepts/containers/images/
image:
  # -- The repository/name/url of the image.
  repository: "rommapp/romm"
  # -- The pull policy for the image.
  pullPolicy: "Always"
  # -- The tag of the image. If not set, the chart's `appVersion` is used.
  tag: ""

# -- Secrets for pulling an image from a private repository.
#
# Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []

# -- Annotations to add to the pod(s).
#
# Ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}

# -- Extra labels to add to the pod(s).
#
# Ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
extraPodLabels: {}

# -- Resource limits and requests.
# You might want to set `limits.cpu` to `null`: https://home.robusta.dev/blog/stop-using-cpu-limits
#
# Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
resources:
  requests:
    cpu: "100m"
    memory: "512Mi"
    ephemeral-storage: "128Mi"
  limits:
    cpu: "500m"
    memory: "512Mi"
    ephemeral-storage: "128Mi"

# -- The security context for the pod.
#
# Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
podSecurityContext:
  fsGroup: 10001

# -- The security context for the container.
#
# Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
containerSecurityContext:
  readOnlyRootFilesystem: true
  runAsUser: 10001
  runAsGroup: 10001

# -- The node selector for the pod(s).
#
# Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
nodeSelector: {}

# -- The affinity for the pod(s).
#
# Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
affinity: {}

# -- A host podAntiAffinity, that stops multiple pods from from being scheduled on the same node.
#
# Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
hostPodAntiAffinity:
  # -- Whether to enable the host podAntiAffinity.
  enabled: false
  # -- The weight of the host podAntiAffinity.
  weight: 50

# -- The tolerations for the pod(s).
#
# Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
tolerations: {}

# -- Liveness Probe configuration.
# Liveness probes can be dangerous. Only use them if you really need one.
# See https://srcco.de/posts/kubernetes-liveness-probes-are-dangerous.html for more information.
#
# Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe: {}
  # httpGet:
  #   # -- The path to use for the liveness probe.
  #   path: "/live"
  #   # -- The port to use for the liveness probe.
  #   # This should reference the container ports defined at `.Values.containerPorts`.
  #   port: "http"

# -- Readiness Probe configuration.
#
# Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
readinessProbe:
  httpGet:
    # -- The path to use for the readiness probe.
    path: "/"
    # -- The port to use for the readiness probe.
    # This should reference the container ports defined at `.Values.containerPorts`.
    port: "http"

# -- Autoscaling configuration.
# `romm` makes no statement about multi-instance support, enable this at your own risk.
#
# Ref: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# -- Deployment strategy configuration.
#
# Ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
strategy:
  type: "RollingUpdate"

# -- ConfigMap configuration.
#
# Ref: https://kubernetes.io/docs/concepts/configuration/configmap/
configMap:
  # -- Whether to create a ConfigMap resource.
  enabled: true
  # -- The name of the ConfigMap.
  # The name should reference the ConfigMap name at `.Values.volumeConfig`.
  name: "config"
  # -- Annotations to add to the ConfigMap.
  annotations: {}
  # -- The data to add to the ConfigMap.
  #
  # Ref: https://github.com/rommapp/romm/blob/master/examples/config.example.yml
  data:
    config.yml: |-
      # Config of romm

# -- Configures the pods `volumes` and `volumeMounts`, as well as the Persistent Volume Claims
#
# Ref: https://kubernetes.io/docs/concepts/storage/volumes/
volumeConfig:
  # -- From the `romm` documentation: Resources like covers, screenshots, etc.
  resources:
    # -- Will be added to the pods `volumeMounts`.
    volumeMount:
      name: "resources"
      mountPath: "/romm/resources"
    # -- Will be added to the pods `volumes` if `persistence.enabled` is `false`.
    volume:
      name: "resources"
      emptyDir: {}
    # -- Persistent Volume Claim configuration
    persistence:
      enabled: false
      pvcName: "resources"
      annotations: {}
      accessModes:
        - "ReadWriteOnce"
      size: "1Gi"
      storageClass: ""
      # -- Will be added to the pods `volumes` if `persistence.enabled` is `true`.
      volume:
        name: "resources"
        persistentVolumeClaim:
          claimName: "resources"
  # -- From the `romm` documentation: The game library
  library:
    volumeMount:
      name: "library"
      mountPath: "/romm/library"
    # -- Will be added to the pods `volumes` if `persistence.enabled` is `false`.
    volume:
      name: "library"
      emptyDir: {}
    # -- Persistent Volume Claim configuration
    persistence:
      enabled: false
      pvcName: "library"
      annotations: {}
      accessModes:
        - "ReadWriteOnce"
      size: "1Gi"
      storageClass: ""
      # -- Will be added to the pods `volumes` if `persistence.enabled` is `true`.
      volume:
        name: "library"
        persistentVolumeClaim:
          claimName: "library"
  # -- From the `romm` documentation: Saves, states, etc.
  assets:
    volumeMount:
      name: "assets"
      mountPath: "/romm/assets"
    # -- Will be added to the pods `volumes` if `persistence.enabled` is `false`.
    volume:
      name: "assets"
      emptyDir: {}
    # -- Persistent Volume Claim configuration
    persistence:
      enabled: false
      pvcName: "assets"
      annotations: {}
      accessModes:
        - "ReadWriteOnce"
      size: "1Gi"
      storageClass: ""
      # -- Will be added to the pods `volumes` if `persistence.enabled` is `true`.
      volume:
        name: "assets"
        persistentVolumeClaim:
          claimName: "assets"
  # -- From the `romm` documentation: Redis data. Redis is integrated into the docker image.
  redisData:
    volumeMount:
      name: "redis-data"
      mountPath: "/redis-data"
    # -- Will be added to the pods `volumes` if `persistence.enabled` is `false`.
    volume:
      name: "redis-data"
      emptyDir: {}
    # -- Persistent Volume Claim configuration
    persistence:
      enabled: false
      pvcName: "redis-data"
      annotations: {}
      accessModes:
        - "ReadWriteOnce"
      size: "1Gi"
      storageClass: ""
      # -- Will be added to the pods `volumes` if `persistence.enabled` is `true`.
      volume:
        name: "redis-data"
        persistentVolumeClaim:
          claimName: "redis-data"
  # -- Directory for the romm config file
  config:
    volumeMount:
      name: "config"
      mountPath: "/romm/config"
    volume:
      name: "config"
      configMap:
        # The name should reference the ConfigMap name at `.Values.configMap.name`.
        name: "config"
  # -- Required by romm for temporary files
  tmp:
    volumeMount:
      name: "tmp"
      mountPath: "/tmp"
    volume:
      name: "tmp"
      emptyDir: {}
  # -- Required by romm for nginx configuration
  nginxConf:
    volumeMount:
      name: "nginx-conf"
      mountPath: "/etc/nginx/conf.d"
    volume:
      name: "nginx-conf"
      emptyDir: {}

# -- Configuration for service accounts.
#
# Ref: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # -- Whether a service account should be created.
  enabled: true
  # -- Whether to mount a ServiceAccount's API credentials.
  automount: true
  # -- Annotations to add to the service account.
  annotations: {}
  # -- The name of the service account to use.
  # If not set, a name is generated based on the chart name.
  name: ""

# -- The ports of the container.
# To use these ports in the service(s),
# you need to add them to `.Values.service.ports` or `.Values.metrics.service.ports`.
#
#
# If `.Values.livenessProbe.enabled` is true, you need to add them to `.Values.livenessProbe`.
#
# If `.Values.readinessProbe.enabled` is true, you need to add them to `.Values.readinessProbe`.
#
# Ref: https://kubernetes.io/docs/concepts/services-networking/service/
#
# Ref: https://kubernetes.io/docs/concepts/services-networking/network-policies/
containerPorts:
  - name: "http"
    port: 8080
    protocol: "TCP"

# -- Service configuration.
# A service for metrics is created separately. Check `.Values.metrics` for more information.
#
# Ref: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # -- The type of service to create.
  #
  # Ref: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: "ClusterIP"
  # -- The ports of the service.
  # These should reference the container ports defined at `.Values.containerPorts`.
  # When `.Values.ingress.enabled` is `true`, they should reference `.Values.ingress.hosts`.
  #
  # Ref: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
  ports:
    - name: "http"
      port: 8080
      protocol: "TCP"
      targetPort: "http"

# -- Ingress configuration.
#
# Ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  # -- Whether to create an Ingress resource.
  enabled: false
  # -- Annotations to add to the Ingress.
  annotations: {}
    # kubernetes.io/ingress.class: "nginx"
    # cert-manager.io/cluster-issuer: "dns01-cloudflare-cluster-issuer-prod"
  # -- The class of the Ingress controller.
  className: "nginx"
  # -- The hosts of the Ingress.
  hosts:
    - host: "romm.example.com"
      paths:
        - path: "/"
          pathType: "Prefix"
          # -- The service port name to use for the Ingress.
          # This should reference the service ports defined at `.Values.service.ports`.
          servicePortName: "http"
  # -- The TLS configuration for the Ingress.
  tls:
    - hosts:
        - "romm.example.com"
      secretName: "romm-tls"

# -- Pod Disruption Budget configuration.
#
# Ref: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
podDisruptionBudget:
  # -- Whether to create a PodDisruptionBudget resource.
  enabled: false
  # -- Annotations to add to the PodDisruptionBudget.
  annotations: {}
  # -- The minimum number of pods that must be available. If set, maxUnavailable won't be used.
  minAvailable: 1
  # -- The maximum number of pods that can be unavailable. Ignored if `minAvailable` is set.
  maxUnavailable: 1
  # -- The Unhealthy Pod Eviction Policy.
  unhealthyPodEvictionPolicy: "AlwaysAllow"

# -- App configuration.
app:
  # -- Environment variables to pass to the container.
  #
  # Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/
  # Ref: https://docs.romm.app/latest/Getting-Started/Environment-Variables/
  env:
    # This should reference the port defined at `.Values.containerPorts`.
    - name: "ROMM_PORT"
      value: "8080"
    # - name: "ROMM_DB_DRIVER"
    #   value: "postgresql"
    # - name: "DB_HOST"
    #   value: "romm-postgresql-cluster-rw"
    # - name: "DB_PORT"
    #   value: "5432"
    # - name: "DB_NAME"
    #   value: "romm"
    # - name: "DB_USER"
    #   valueFrom:
    #     secretKeyRef:
    #       name: "romm-db-credentials"
    #       key: "username"
    # - name: "DB_PASSWD"
    #   valueFrom:
    #     secretKeyRef:
    #       name: "romm-db-credentials"
    #       key: "password"
    # # Generate this with `openssl rand -hex 32`
    # - name: "ROMM_AUTH_SECRET_KEY"
    #   valueFrom:
    #     secretKeyRef:
    #       name: "romm-auth-secret-key"
    #       key: "secretKey"
    # - name: "HASHEOUS_API_ENABLED"
    #   value: "true"

  # -- Arguments to pass to the containers entrypoint.
  #
  # Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
  args: []
